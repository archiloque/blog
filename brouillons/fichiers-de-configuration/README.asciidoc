= Fichiers de configuration
Julien Kirch
v0.1, 2021-05-25
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Vous √©crivez un programme, et vous d√©cidez de mettre en place un syst√®me bas√© sur un fichier de configuration pour le param√©trer.

Si vous ajoutez des fonctionnalit√©s √† votre programme, la configuration va se complexifier peu √† peu, mais partons du d√©but.

== Le d√©but

La premi√®re √©tape est en g√©n√©ral de d√©finir une s√©rie de cl√©-valeur, pour remplacer une trop longue s√©rie de variables d'environnement ou de param√®tres en ligne de commandes.

[source,ini]
----
property_1=value_1
property_2=value_2
----

Jusque l√† tout va bien.

Il peut √™tre n√©cessaire de pouvoir utiliser des `=` dans les valeurs, ce qui signifie permettre des √©chappements.

[source,ini]
----
property_1="val=ue1"
property_2="va=lu\"e_2"
----

Ensuite, on peut vouloir que certaines valeurs ne soient pas seulement des cha√Ænes de caract√®res, mais aussi parfois des listes ou des dictionnaires (c'est-√†-dire que les valeurs puissent elles-m√™mes un ensemble cl√©-valeur).

[source,ini]
----
property_1=["val=ue1", "val=ue11"]
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

Quand le nombre d'entr√©es devient trop grand, et pour pouvoir r√©utiliser les noms de cl√©s, on peut vouloir organiser le contenu du fichier en d√©finissant des sections.

[source,ini]
----
[section 1]
property_1=["val=ue1", "val=ue11"]
property_2=value3

[section 2]
property_1=üê∞
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

== La limite sans fichier de configuration

On a ici d√©pass√© ce qu'on peut faire confortablement avec des param√®tres ou des variables d'environnements.
Il reste possible de passer des listes dans des cha√Ænes de caract√®res et d'utiliser des pr√©fixes pour simuler les sections, le r√©sultat est moins lisible, surtout s'il y a de nombreuses entr√©es.

== La factorisation ou la compilation pour les fichiers de configuration

Quand le fichier de configuration s'allonge et que le contenu se r√©p√®te, le r√©flexe quand on travaille dans le d√©veloppement est de vouloir faire de la factorisation.
Par exemple en attribuant un nom √† un certain contenu, et en utilisant ce nom pour inclure ce contenu ailleurs dans le fichier

[source,ini]
----
&üê±=nya

property_1=*üê±
property_2=*üê±
----

Dans ce cas le contenu que vous √©ditez n'est plus directement celui qui sera utilis√© par le programme car le fichier va subir un traitement qui va modifier son contenu.
Cela ressemble grosso-modo √† une phase de compilation (ou de transpilation).

Pour certaines investigation, il peut devenir utile de pouvoir avoir acc√®s au contenu trait√© tel qu'il sera visible depuis le programme.

Dans l'exemple ci-dessus, cela signifie √™tre en mesure d'obtenir ce contenu{nbsp}:

[source,ini]
----
property_1=nya
property_2=nya
----

Si votre fichier de configuration utilise une syntaxe normalis√©e, les personnes √©ditant le fichier peuvent peut-√™tre s'appuyer sur des outils existants.
Dans le cas contraire c'est √† vous de le fournir.

Si votre format de fichier de configuration ne permet pas ce genre de factorisation, il est possible que les personnes se retrouvent √† r√©pondre √† leur besoin dans ce domaine en g√©n√©rant leurs fichiers de configuration √† partir d'un outil de templating.

== En passant{nbsp}: le templating

Mais en fait, m√™me si votre format de configuration fournit des fonctionnalit√©s avanc√©es de factorisation, il est assez probable que des personnes vont vouloir g√©n√©rer ces fichiers √† partir d'un autre outil.

Pour un outil utilis√© par des serveurs, cela peut √™tre pour des raisons d'industrialisation de d√©ploiement, mais le besoin se fera probablement sentir m√™me pour un outil r√©serv√©s aux postes de travail.

Cela signifie que plus votre format de fichier sera facile √† templatiser, plus vous simplifierez ces cas d'utilisation.

Dans mon exp√©rience, deux choses sont √† prendre en compte pour cela{nbsp}:

. le fait d'avoir une syntaxe r√©guli√®re avec un nombre d'exceptions limit√©es{nbsp};
. le fait d'utiliser des r√®gles d'√©chappement standard.

La deuxi√®me r√®gle √©tant bien plus importante que la premi√®re car impl√©menter une gestion des √©chappements demande du code assez minutieux et bien test√©, c'est-√†-dire quelque chose qu'on pr√©f√®re en g√©n√©ral √©viter quand on le peut.

== La factorisation{nbsp}: n√©cessaire ou pas alors{nbsp}?

Si proposer une capacit√© de factorisation dans une syntaxe de configuration est utile, je suis partag√© sur le fait de savoir si le jeu en vaut la chandelle √† cause de la complexit√© que cela ajoute.

Je suis probablement partial en tant que d√©veloppeur et du fait qu'utiliser du templating est facile pour moi, mais d'un autre c√¥t√© je soup√ßonne que beaucoup des personnes qui utilisent la factorisation seraient aussi en mesure d'utiliser du templating.

== Les comportements dynamiques

La derni√®re √©tape dans la complexit√© d'un fichier de configuration est d'avoir des comportements dynamiques, c'est √† dire qui d√©pendent de l'ex√©cution du programme.

Par exemple avoir des conditions{nbsp}:

[source,ini]
----
if animal == cat
then nya
----

Par rapport √† la factorisation, les comportements dynamiques ne sont pas une optimisation d'√©criture des fichiers mais permettent des comportements qui sinon sont impossibles.

Si on peut continuer √† voir cela comme un fichier de configuration, le comportement s'apparente v√©ritablement √† du code.

De m√™me que la factorisation rend utile d'avoir acc√®s √† une version d√©velopp√©e du fichier, avoir un comportement dynamique rend utile de pouvoir observer d'une mani√®re ou d'une autre le fonctionnement du logiciel (par exemple via des logs d√©taill√©s), et m√™me id√©alement de pouvoir le d√©bugger.

Il y a quelques ann√©es, il y avait une certaine logique √† d√©velopper son propre syst√®me pour cela, soit √† inventer sa propre syntaxe √† ajouter √† un format de fichier existant.

Par exemple avec link:https://ant.apache.org[ce genre de choses]{nbsp}:

[source,xml]
----
<if>
    <equals arg1="${condition}" arg2="true"/>
    <then>
        <copy file="${some.dir}/file" todir="${another.dir}"/>
    </then>
    <elseif>
        <equals arg1="${condition}" arg2="false"/>
        <then>
            <copy file="${some.dir}/differentFile" todir="${another.dir}"/>
        </then>
    </elseif>
    <else>
        <echo message="Condition was neither true nor false"/>
    </else>
</if>
----


''''

√Ä r√©diger :

Quand on a factorisation en cascade, on se retrouve √† avoir du mal √† suivre ce qui se passe, parfois on a ajoute l'√©quivalent de logs en √©crivant des contenus interm√©diaires pour pouvoir suivre ce qui se passe, et on aimerait bien pouvoir d√©bugger dans les cas extr√™me.

On a un traitement => c'est un programme qu'on execute.

Suite : les conditions, et les boucles.

Dans ce cas on a clairement un comportement dynamique.

Souvent on a du mal √† se dire qu'on veut du code car on voit √ßa comme de la configuration, mais ce n'est pas diff√©rent d'une phase de compilation.

Il y a quelques ann√©es c'√©tait difficile d'utiliser un langage de programmation pour √ßa mais √ßa n'est plus le cas.

Je pense m√™me qu'il est souhaitable d'avoir un langage de programmation statique, qui permette de faire de la v√©rification de format et le typage sur le contenu. L'√©quivalent des validation de sch√©ma en XML.

On peut le faire depuis le code qui utilise la configuration, mais l'avoir dans le langage de configuration permet d'avoir de la validation dans l'√©diteur.