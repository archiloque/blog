= Fichiers de configuration
Julien Kirch
v0.1, 2021-05-25
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly
:article_image: xml.png
:article_description: Jusqu'o√π aller dans la complexit√©

Vous √©crivez un programme, et vous d√©cidez de mettre en place un syst√®me bas√© sur un fichier de configuration pour le param√©trer.

Si vous ajoutez des fonctionnalit√©s √† votre programme, la configuration va se complexifier peu √† peu, mais partons du d√©but.

== Le d√©but

La premi√®re √©tape est en g√©n√©ral de d√©finir une s√©rie de cl√©-valeur, pour remplacer une trop longue s√©rie de variables d'environnement ou de param√®tres en ligne de commandes.

[source,ini]
----
property_1=value_1
property_2=value_2
----

Jusque l√† tout va bien.

Il peut √™tre n√©cessaire de pouvoir utiliser des `=` dans les valeurs, ce qui signifie permettre des √©chappements.

[source,ini]
----
property_1="val=ue1"
property_2="va=lu\"e_2"
----

Ensuite, on peut vouloir que certaines valeurs ne soient pas seulement des cha√Ænes de caract√®res, mais aussi parfois des listes ou des dictionnaires (c'est-√†-dire que les valeurs puissent elles-m√™mes un ensemble cl√©-valeur).

[source,ini]
----
property_1=["val=ue1", "val=ue11"]
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

Quand le nombre d'entr√©es devient trop grand, et pour pouvoir r√©utiliser les noms de cl√©s, on peut vouloir organiser le contenu du fichier en d√©finissant des sections.

[source,ini]
----
[section 1]
property_1=["val=ue1", "val=ue11"]
property_2=value3

[section 2]
property_1=üê∞
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

== La limite sans fichier de configuration

On a ici d√©pass√© ce qu'on peut faire confortablement avec des param√®tres ou des variables d'environnements.
Il reste possible de passer des listes dans des cha√Ænes de caract√®res et d'utiliser des pr√©fixes pour simuler les sections, le r√©sultat est moins lisible, surtout s'il y a de nombreuses entr√©es.

== La factorisation ou la compilation pour les fichiers de configuration

Quand le fichier de configuration s'allonge et que le contenu se r√©p√®te, le r√©flexe quand on travaille dans le d√©veloppement est de vouloir faire de la factorisation.
Par exemple en attribuant un nom √† un certain contenu, et en utilisant ce nom pour inclure ce contenu ailleurs dans le fichier{nbsp}:

[source,ini]
----
&üê±=nya

property_1=*üê±
property_2=*üê±
----

Dans ce cas le contenu que vous √©ditez n'est plus directement celui qui sera utilis√© par le programme car le fichier va subir un traitement qui va modifier son contenu.
Cela ressemble grosso-modo √† une phase de compilation (ou de transpilation).

Pour certaines investigation, il peut devenir utile de pouvoir avoir acc√®s au contenu trait√© tel qu'il sera visible depuis le programme.

Dans l'exemple ci-dessus, cela signifie √™tre en mesure d'obtenir ce contenu{nbsp}:

[source,ini]
----
property_1=nya
property_2=nya
----

Si votre fichier de configuration utilise une syntaxe normalis√©e, les personnes √©ditant le fichier peuvent s'appuyer sur des outils existants pour g√©n√©rer eux-m√™me le r√©sultat.

Dans le cas contraire c'est √† vous de le fournir.

== La g√©n√©ration de fichiers

Si votre format de fichier de configuration ne permet pas ce genre de factorisation, il est possible que les personnes se retrouvent √† r√©pondre ce type de besoin en g√©n√©rant leurs fichiers de configuration √† l'aide d'un autre outil.

Mais en fait, m√™me si votre format de configuration fournit des fonctionnalit√©s avanc√©es de factorisation, il est assez probable que des personnes vont vouloir g√©n√©rer ces fichiers √† partir d'un autre outil.

Pour un outil utilis√© par des serveurs, cela peut √™tre pour industrialiser le d√©ploiement, mais le besoin se fera probablement sentir m√™me pour un outil r√©serv√©s aux postes de travail.

Cela signifie que plus votre format de fichier sera facile √† g√©n√©rer, plus vous simplifierez ces cas d'utilisation.

Dans mon exp√©rience, deux choses sont √† prendre en compte pour cela{nbsp}:

. le fait d'avoir une syntaxe r√©guli√®re avec un nombre d'exceptions limit√©es{nbsp};
. le fait d'utiliser des r√®gles d'√©chappement standard.

La deuxi√®me r√®gle √©tant bien plus importante que la premi√®re car impl√©menter une gestion des √©chappements demande du code assez minutieux et bien test√©, c'est-√†-dire quelque chose qu'on pr√©f√®re en g√©n√©ral √©viter quand on le peut.

== La factorisation{nbsp}: n√©cessaire ou pas alors{nbsp}?

Si proposer une capacit√© de factorisation dans une syntaxe de configuration est utile, je suis partag√© sur le fait de savoir si le jeu en vaut la chandelle √† cause de la complexit√© que cela ajoute.

Je suis probablement partial en tant que d√©veloppeur et du fait qu'√©crire des scripts pour g√©n√©rer des fichiers est facile pour moi, mais d'un autre c√¥t√© je soup√ßonne que beaucoup des personnes qui utilisent la factorisation seraient aussi en mesure de g√©n√©rer les fichiers.

== Les comportements dynamiques

La derni√®re √©tape dans la complexit√© d'un fichier de configuration est d'avoir des comportements dynamiques, c'est √† dire qui d√©pendent de l'ex√©cution du programme.

Par exemple avoir des conditions{nbsp}:

[source,ini]
----
if animal == cat
then nya
----

Par rapport √† la factorisation, les comportements dynamiques ne sont pas une optimisation d'√©criture des fichiers mais permettent des comportements qui sinon sont impossibles.

Si on peut continuer √† voir cela comme un fichier de configuration, le comportement s'apparente v√©ritablement √† du code.

De m√™me que la factorisation rend utile d'avoir acc√®s √† une version d√©velopp√©e du fichier, avoir un comportement dynamique rend utile de pouvoir observer d'une mani√®re ou d'une autre le fonctionnement du logiciel (par exemple via des logs d√©taill√©s), et m√™me id√©alement de pouvoir le d√©bugger.

Il y a quelques ann√©es embarquer un intepr√©teur dans un programme ex√©cutable n'√©tait pas chose facile.
Dans ces conditions, d√©velopper son propre format ou √©tendre un format de existant pour cela avait du sens.

Par exemple avec link:https://ant.apache.org[ce genre de choses]{nbsp}:

[source,xml]
----
<if>
    <equals arg1="${condition}" arg2="true"/>
    <then>
        <copy file="${some.dir}/file" todir="${another.dir}"/>
    </then>
    <elseif>
        <equals arg1="${condition}" arg2="false"/>
        <then>
            <copy file="${some.dir}/differentFile" todir="${another.dir}"/>
        </then>
    </elseif>
    <else>
        <echo message="Condition was neither true nor false"/>
    </else>
</if>
----

Mais de nos jours, embarquer un interpr√©teur comme link:https://www.lua.org/about.html[Lua] est relativement facile et assez commun.

Ce qui signifie que les personnes peuvent utiliser leurs outils de d√©veloppement pour √©crire leurs fichiers de configuration et peuvent m√™me les d√©buger en cas de besoin.

Certes passer de fichier de configuration √† des fichiers de code repr√©sente un changement qu'on n'imaginait pas forc√©ment faire.
Mais de fait quand un fichier de configuration contient du code d√©guis√© en configuration, il est d√©j√† un fichier de code sans oser l'assumer, et sans permettre d'utiliser les outils pr√©vu pour √ßa.

Ma suggestion est donc de sauter le pas.

Si vous pensez que ce conseil est inutile car cela n'arrive plus (et notamment par ce que seules des personnes faisant du XML et du Java pourraient avoir ce genre d'id√©es), malheureusement c'est toujours le cas, seulement link:https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html[avec du YAML au lieu de XML].

[source,yaml]
----
tasks:
  - name: Shut down CentOS 6 and Debian 7 systems
    ansible.builtin.command: /sbin/shutdown -t now
    when: (ansible_facts['distrib'] == "CentOS" and ansible_facts['distrib_mv'] == "6") or
          (ansible_facts['distrib'] == "Debian" and ansible_facts['distrib_mv'] == "7")
----

== En r√©sum√©

* D√®s qu'un fichier de configuration passe par une phase de transformation, il faut pouvoir observer ce qui se passe.
* Si vous inventez votre syntaxe, pensez bien aux personnes qui voudront g√©n√©rer des fichiers.
* Lorsque la configuration d'un programme n√©cessite des comportements dynamiques, utilisez un langage de programmation.