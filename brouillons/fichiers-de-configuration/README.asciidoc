= Fichiers de configuration
Julien Kirch
v0.1, 2021-05-25
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Vous √©crivez un programme, et vous d√©cidez de mettre en place un syst√®me bas√© sur un fichier de configuration pour le param√©trer.

Si vous ajoutez des fonctionnalit√©s √† votre programme, la configuration va se complexifier peu √† peu, mais partons du d√©but.

== Le d√©but

La premi√®re √©tape est en g√©n√©ral de d√©finir une s√©rie de cl√©-valeur, pour remplacer une trop longue s√©rie de variables d'environnement ou de param√®tres en ligne de commandes.

[source,ini]
----
property_1=value_1
property_2=value_2
----

Jusque l√† tout va bien.

Il peut √™tre n√©cessaire de pouvoir utiliser des `=` dans les valeurs, ce qui signifie permettre des √©chappements.

[source,ini]
----
property_1="val=ue1"
property_2="va=lu\"e_2"
----

Ensuite, on peut vouloir que certaines valeurs ne soient pas seulement des cha√Ænes de caract√®res, mais aussi parfois des listes ou des dictionnaires (c'est-√†-dire que les valeurs puissent elles-m√™mes un ensemble cl√©-valeur).

[source,ini]
----
property_1=["val=ue1", "val=ue11"]
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

Quand le nombre d'entr√©es devient trop grand, et pour pouvoir r√©utiliser les noms de cl√©s, on peut vouloir organiser le contenu du fichier en d√©finissant des sections.

[source,ini]
----
[section 1]
property_1=["val=ue1", "val=ue11"]
property_2=value3

[section 2]
property_1=üê∞
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

== La limite sans fichier de configuration

On a ici d√©pass√© ce qu'on peut faire confortablement avec des param√®tres ou des variables d'environnements.
Il reste possible de passer des listes dans des cha√Ænes de caract√®res et d'utiliser des pr√©fixes pour simuler les sections, le r√©sultat est moins lisible, surtout s'il y a de nombreuses entr√©es.

== La factorisation ou la compilation pour les fichiers de configuration

Quand le fichier de configuration s'allonge et que le contenu se r√©p√®te, le r√©flexe quand on travaille dans le d√©veloppement est de vouloir faire de la factorisation.
Par exemple en attribuant un nom √† un certain contenu, et en utilisant ce nom pour inclure ce contenu ailleurs dans le fichier

[source,ini]
----
&üê±=nya

property_1=*üê±
property_2=*üê±
----

Dans ce cas le contenu que vous √©ditez n'est plus directement celui qui sera utilis√© par le programme car le fichier va subir un traitement qui va modifier son contenu.
Cela ressemble grosso-modo √† une phase de compilation (ou de transpilation).

Pour certaines investigation, il peut devenir utile de pouvoir avoir acc√®s au contenu trait√© tel qu'il sera visible depuis le programme.

Dans l'exemple ci-dessus, cela signifie √™tre en mesure d'obtenir ce contenu{nbsp}:

[source,ini]
----
property_1=nya
property_2=nya
----

Si votre fichier de configuration utilise une syntaxe normalis√©e, les personnes √©ditant le fichier peuvent peut-√™tre s'appuyer sur des outils existants.
Dans le cas contraire c'est √† vous de le fournir.

Si votre format de fichier de configuration ne permet pas ce genre de factorisation, il est possible que les personnes se retrouvent √† r√©pondre √† leur besoin dans ce domaine en g√©n√©rant leurs fichiers de configuration √† partir d'un outil de templating.

== En passant{nbsp}: le templating

Mais en fait, m√™me si votre format de configuration fournit des fonctionnalit√©s avanc√©es de factorisation, il est assez probable que des personnes vont vouloir g√©n√©rer ces fichiers √† partir d'un autre outil.

Pour un outil utilis√© par des serveurs, cela peut √™tre pour des raisons d'industrialisation de d√©ploiement, mais le besoin se fera probablement sentir m√™me pour un outil r√©serv√©s aux postes de travail.

Cela signifie que plus votre format de fichier sera facile √† templatiser, plus vous simplifierez ces cas d'utilisation.

Dans mon exp√©rience, deux choses sont √† prendre en compte pour cela{nbsp}:

. le fait d'avoir une syntaxe r√©guli√®re avec un nombre d'exceptions limit√©es{nbsp};
. le fait d'utiliser des r√®gles d'√©chappement standard.

La deuxi√®me r√®gle √©tant bien plus importante que la premi√®re cet impl√©menter une gestion des √©chappements demande du code assez minutieux et bien test√©.

== 

''''

√Ä r√©diger :

Quand on a factorisation en cascade, on se retrouve √† avoir du mal √† suivre ce qui se passe, parfois on a ajoute l'√©quivalent de logs en √©crivant des contenus interm√©diaires pour pouvoir suivre ce qui se passe, et on aimerait bien pouvoir d√©bugger dans les cas extr√™me.

On a un traitement => c'est un programme qu'on execute.

Suite : les conditions, et les boucles.

Dans ce cas on a clairement un comportement dynamique.

Souvent on a du mal √† se dire qu'on veut du code car on voit √ßa comme de la configuration, mais ce n'est pas diff√©rent d'une phase de compilation.

Il y a quelques ann√©es c'√©tait difficile d'utiliser un langage de programmation pour √ßa mais √ßa n'est plus le cas.

Je pense m√™me qu'il est souhaitable d'avoir un langage de programmation statique, qui permette de faire de la v√©rification de format et le typage sur le contenu. L'√©quivalent des validation de sch√©ma en XML.

On peut le faire depuis le code qui utilise la configuration, mais l'avoir dans le langage de configuration permet d'avoir de la validation dans l'√©diteur.