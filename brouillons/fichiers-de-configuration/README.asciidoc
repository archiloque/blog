= Fichiers de configuration
Julien Kirch
v0.1, 2021-05-25
:article_lang: fr
:source-highlighter: pygments
:pygments-style: friendly

Vous √©crivez un programme, et vous d√©cidez de mettre en place un syst√®me bas√© sur un fichier de configuration pour le param√©trer.

Si vous ajoutez des fonctionnalit√©s √† votre programme, la configuration va se complexifier peu √† peu, mais partons du d√©but.

== Le d√©but

La premi√®re √©tape est en g√©n√©ral de d√©finir une s√©rie de cl√©-valeur, pour remplacer une trop longue s√©rie de variables d'environnement ou de param√®tres en ligne de commandes.

[source,ini]
----
property_1=value_1
property_2=value_2
----

Jusque l√† tout va bien.

Il peut √™tre n√©cessaire de pouvoir utiliser des `=` dans les valeurs, ce qui signifie permettre des √©chappements.

[source,ini]
----
property_1="val=ue1"
property_2="va=lu\"e_2"
----

Ensuite, on peut vouloir que certaines valeurs ne soient pas seulement des cha√Ænes de caract√®res, mais aussi parfois des listes ou des dictionnaires (c'est-√†-dire que les valeurs puissent elles-m√™mes un ensemble cl√©-valeur).

[source,ini]
----
property_1=["val=ue1", "val=ue11"]
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

Quand le nombre d'entr√©es devient trop grand, et pour pouvoir r√©utiliser les noms de cl√©s, on peut vouloir organiser le contenu du fichier en d√©finissant des sections.

[source,ini]
----
[section 1]
property_1=["val=ue1", "val=ue11"]
property_2=value3

[section 2]
property_1=üê∞
property_2={"va=lu\"e_2": "a", "va=lu\"e_22": "b"}
----

== La limite

On a ici d√©pass√© ce qu'on peut faire confortablement avec des param√®tres ou des variables d'environnements.
Il reste possible de passer des listes dans des cha√Ænes de caract√®res et d'utiliser des pr√©fixes pour simuler les sections, le r√©sultat est moins lisible, surtout s'il y a de nombreuses entr√©es.

Cette √©tape correspond pour moi au point d'utilit√© maximale des fichiers de configuration{nbsp}: on est capable de saisir du contenu avec une certaine expressivit√© et aucun traitement n'est apport√© ensuite au contenu, ce qui fait que le contenu visible est exactement celui qui sera utilis√©footnote:[En r√©alit√© il ne s'agit pas exactement du contenu visible √† cause des √©chappements, mais je pense que sauf dans de tr√®s rare situations il n'est pas possible de s'en passer.].

== √áa commence √† ne plus aller

Quand le fichier de configuration s'allonge et que le contenu se r√©p√®te, le r√©flexe quand on travaille dans le d√©veloppement est de vouloir faire de la factorisation.
Par exemple en attribuant un nom √† un certain contenu, et en utilisant ce nom pour inclure ce contenu ailleurs dans le fichier

[source,ini]
----
&üê±=nya

property_1=*üê±
property_2=*üê±
----

Dans ce cas le contenu que vous √©ditez n'est plus celui qui sera utilis√© par le programme car le fichier va subir un traitement qui va modifier son contenu, qui ressemble grosso-modo √† une phase de compilation.

Pour comprendre ce qui se passe, il peut devenir int√©ressant de pouvoir avoir acc√®s au contenu trait√© tel qu'il sera visible depuis le programme qui va l'utiliser.

Dans l'exemple ci-dessus, cela signifie √™tre en mesure d'obtenir ce contenu{nbsp}:

[source,ini]
----
property_1=nya
property_2=nya
----

Cela signifie s'appuyer sur un programme externe s'il s'agit d'une syntaxe normalis√©e et que de tels outils existent, ou de fournir cette capacit√© via ce programme.

Si votre format de fichier de configuration ne permet pas ce genre de construction, il est possible que les personnes se retrouvent √† devoir g√©n√©rer vos fichiers de configuration pour atteindre le m√™me r√©sultat.




''''

√Ä r√©diger :

Quand on a factorisation en cascade, on se retrouve √† avoir du mal √† suivre ce qui se passe, parfois on a ajoute l'√©quivalent de logs en √©crivant des contenus interm√©diaires pour pouvoir suivre ce qui se passe, et on aimerait bien pouvoir d√©bugger dans les cas extr√™me.

On a un traitement => c'est un programme qu'on execute.

Suite : les conditions, et les boucles.

Dans ce cas on a clairement un comportement dynamique.

Souvent on a du mal √† se dire qu'on veut du code car on voit √ßa comme de la configuration, mais ce n'est pas diff√©rent d'une phase de compilation.

Il y a quelques ann√©es c'√©tait difficile d'utiliser un langage de programmation pour √ßa mais √ßa n'est plus le cas.

Je pense m√™me qu'il est souhaitable d'avoir un langage de programmation statique, qui permette de faire de la v√©rification de format et le typage sur le contenu. L'√©quivalent des validation de sch√©ma en XML.

On peut le faire depuis le code qui utilise la configuration, mais l'avoir dans le langage de configuration permet d'avoir de la validation dans l'√©diteur.