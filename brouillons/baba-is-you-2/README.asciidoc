[#baba-is-you-2]
ifeval::["{doctype}" == "book"]
= Part 2: plumbing
endif::[]
ifeval::["{doctype}" != "book"]
= Writing a "`Baba Is You`" solver, part 2: plumbing
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:docdate: 2019-05-09
:article_lang: en
:ignore_files: app1.java, fifoqueue1.java, graph1.asciidoc, graph1.mmd, graph1.png, level1.java, level2.java, log1.txt, state1.java
:article_image: first-level1.png
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:article_description: Technical code and no business logic, at least I avoided creating a framework…
:figure-caption!:

ifeval::["{doctype}" == "book"]
In the previous part
endif::[]
ifeval::["{doctype}" != "book"]
In link:../baba-is-you-1/[the previous part]
endif::[]
I wrote the code to read the levels.
While I'd love to jump straight to the solving logic, I need to establish the game loop first. It's plumbing time!

This is fairly generic code, and I was able to port most of it from my previous link:https://github.com/archiloque/rgbexpress[efforts].

include::graph1.asciidoc[]

== The level

I'll use a `Level` class to hold all the data related to a game level.
For now it will just contain the level data we read from disk. I know from experience that I'll add other data to simplify and speed up the calculations.

.Level.java
[source,java]
----
include::level1.java[]
----

My next class, the `State`, represents a state of the game being solved.
Just as the `Level`, it starts out as a small class with few attributes (the current status of the game and a reference to the `Level`) and it will become larger as I add features, for example to store the dynamic rules.

.State.java
[source,java]
----
include::state1.java[]
----

== The list of states

I could represent my list of game states as a link:https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)[FIFO queue] to implement a link:https://en.wikipedia.org/wiki/Depth-first_search[depth-first search] or as a link:https://en.wikipedia.org/wiki/Stack_(abstract_data_type)[stack] for link:https://en.wikipedia.org/wiki/Breadth-first_search[breadth-first search].

A FIFO may find a solution faster but the solution may be inefficient, a stack finds the solution that requires the lowest number of move, but requires more time and memory.

Which works best depends on the game I'm solving. Rather than choose by a fixed criterion, I just start from something that makes sense and tweak as I go. 

My last project used a FIFO queue so let's use that.

////
Je ne suis pas vraiment convaincu de l'intérêt de voir le code de la FIFO, mais ce n'est que mon avis.
////

.FiFoQueue.java
[source,java]
----
include::fifoqueue1.java[]
----

I use a custom implementation since the code is short and it's only doing what I need.

Then, I can add the code related to the states list in the `Level`.

.Level.java
[source,java]
----
include::level2.java[]
----

Calling `State#processState` will add some new possible ``State``s to the list, so the minimal version of the solver loop is now complete.

== The entry point

Finally, my solver needs an entry point.

.App.java
[source,java]
----
include::app1.java[]
----

With the workflow completed, I can now run the program run and watch it solve its first level... well, kind of:

[source]
----
include::log1.txt[]
----

In the next part I'll put all the plumbing to good use and add some logic to the code.
