= Sécurité : se protéger contre les accidents ou contre un acte délibéré
Julien Kirch
v0.1, 2021-02-28
:article_lang: fr
:article_image: risk.jpeg
:article_description: La manière forte ou pas

Quand on parle de sécurité ou d'isolation en informatique, pour mieux se comprendre je pense qu'il serait utile de distinguer deux choses.

- Lorsqu'on veut se protéger contre les accidents
- Lorsqu'on veut se protéger contre un acte délibéré

Prenons le cas des méthodes privées en programmation.

En Ruby, il est facile d'appeler une méthode privée d'une classe.

Si une classe `Chat` implémente une méthode `miaule()`, il est impossible de faire `chat.miaule`.
Il faut utiliser la syntaxe `chat.send(:miaule)`.

L'idée est de ne pas bloquer la possibilité de faire ce type d'appel quand il est nécessaire, mais de faire en sorte qu'il soit délibéré, pour éviter les accidents.

L'approche de Python, qui est de définir les méthodes privées uniquement par une convention de nommagefootnote:[le nom d'une méthode privée méthode privée doit commencer par deux tirets bas] est encore plus libérale.

En Java, au contraire, l'appel d'une méthode privée passe par le fait link:https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html#setAccessible-boolean-[de rendre cette méthode accessible]. La spécification indique que cette opération peut être refusée pour des raisons de sécurité.

Dans ce cas, il est donc possible et même relativement facile d'interdire l'accès à tel ou tel méthode privée, voire à l'ensemble des méthodes privées.
Je ne connais pas l'écosystème Android donc je ne sais pas si cette fonctionnalité y est utilisée, mais côté serveur elle l'était, par exemple pour permettre à des hébergeurs de partager un même serveur d'application entre plusieurs client·e·s.

Ruby choisit donc de se protéger uniquement des accidents, et Java choisit de permettre de se protéger même contre une action délibérée.

Lorsqu'on développe en Ruby (et qu'on vient par exemple du monde Java), on pourrait préférer que Ruby fonctionne comme Java de ce point de vue, ou on pourrait penser que l'implémentation des méthodes privées en Ruby est incomplète.
Mais cela est faux{nbsp}: l'objectif des méthodes privées en Ruby est différent de celles de Java.

Le même genre de chose existe dans les systèmes d'exploitations.

La volonté d'avoir des systèmes performants mène au fait de vouloir partager les ressources et de procéder à des optimisation globales, par exemple les nombreux caches dont les caches de fichiers ou link:https://lwn.net/Articles/814535/[le cache de fichiers qui n'existent pas].

Ces caches ne sont pas isolés par processus ou par utilisateur·rice·s car cela diminuerait l'efficacité du cache tout en augmentant son coût de gestion.

Cela signifie que quand on veut mesurer ou limiter la consommation mémoire d'un processus, ces éléments ne sont pas pris en compte.

Ainsi un processus pourrait privilégier l'utilisation de certains types de ressources qui ne sont pas comptabilisée pour rester sous la limite, ou même priver les autres de ressources en se les accaparant.

Cela ne veut pas dire qu'il n'est pas possible qu'il n'est pas possible de faire évoluer le fonctionnement du système pour prendre ces cas en compte si le problème devient suffisamment grave, mais il ne faut pas mélanger les deux cas.

Et pour un système Linux, augmenter le niveau d'isolation pour se protéger pourra ainsi passer par de la virtualisation, mais qui comme dit plus haut fera perdre les bénéfices qu'on peut tirer du partage de ressources.

La prochaine fois que vous prenez connaissance d'une capacité d'isolation dans un système, posez-vous la question{nbsp}: de quel type s'agit-il{nbsp}?

Cela pourrait vous permettre de gagner du temps et d'éviter des erreurs.