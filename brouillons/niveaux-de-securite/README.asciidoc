= S√©curit√© : se prot√©ger contre les accidents ou contre un acte d√©lib√©r√©
Julien Kirch
v0.1, 2021-02-28
:article_lang: fr
:article_image: risk.jpeg
:article_description: La mani√®re forte ou pas

Quand on parle de s√©curit√© ou d'isolation en informatique, pour mieux se comprendre je pense qu'il serait utile de distinguer deux choses.

- Lorsqu'on veut se prot√©ger contre les accidents
- Lorsqu'on veut se prot√©ger contre un acte d√©lib√©r√©

Prenons le cas des m√©thodes priv√©es en programmation.

En Ruby, il est facile d'appeler une m√©thode priv√©e d'une classe.

Si une classe `Chat` impl√©mente une m√©thode `miaule()`, il est impossible de faire `üêà.miaule`.
Il faut utiliser la syntaxe `üêà.send(:miaule)`.

L'id√©e est de ne pas bloquer la possibilit√© de faire ce type d'appel quand il est n√©cessaire, mais de faire en sorte qu'il soit d√©lib√©r√©, pour √©viter les accidents.

L'approche de Python, qui est de d√©finir les m√©thodes priv√©es uniquement par une convention de nommagefootnote:[le nom d'une m√©thode priv√©e m√©thode priv√©e doit commencer par deux tirets bas] est encore plus lib√©rale.

En Java, au contraire, l'appel d'une m√©thode priv√©e passe par le fait link:https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html#setAccessible-boolean-[de rendre cette m√©thode accessible]. La sp√©cification indique que cette op√©ration peut √™tre refus√©e pour des raisons de s√©curit√©.

Dans ce cas, il est donc possible et m√™me relativement facile d'interdire l'acc√®s √† tel ou tel m√©thode priv√©e, voire √† l'ensemble des m√©thodes priv√©es.
Je ne connais pas l'√©cosyst√®me Android et je ne sais donc pas si cette fonctionnalit√© y est utilis√©e, mais c√¥t√© serveur elle l'√©tait, par exemple pour permettre √† des h√©bergeurs de partager un m√™me serveur d'application entre plusieurs client¬∑e¬∑s quand cette approche avait du sens.

Ruby choisit donc de se prot√©ger uniquement des accidents, et Java choisit de permettre de se prot√©ger m√™me contre une action d√©lib√©r√©e.

Lorsqu'on d√©veloppe en Ruby (et qu'on vient par exemple du monde Java), on pourrait pr√©f√©rer que Ruby fonctionne comme Java de ce point de vue, ou on pourrait penser que l'impl√©mentation des m√©thodes priv√©es en Ruby est incompl√®te.
Mais cela est faux{nbsp}: l'objectif des m√©thodes priv√©es en Ruby est diff√©rent de celles de Java.

Le m√™me genre de chose existe dans les syst√®mes d'exploitations.

La volont√© d'avoir des syst√®mes performants m√®ne au fait de vouloir partager les ressources et de proc√©der √† des optimisation globales, par exemple les nombreux caches dont les caches de fichiers ou link:https://lwn.net/Articles/814535/[le cache de fichiers qui n'existent pas].

Ces caches ne sont pas isol√©s par processus ou par utilisateur¬∑rice¬∑s car cela diminuerait l'efficacit√© du cache en limitant le partage tout en augmentant son co√ªt de gestion.

Cela signifie que quand on veut mesurer ou limiter la consommation m√©moire d'un processus, ces √©l√©ments ne sont pas pris en compte.

Ainsi un processus pourrait privil√©gier l'utilisation de certains types de ressources qui ne sont pas comptabilis√©e pour rester sous la limite, ou m√™me priver les autres de ressources en se les accaparant.

Cela ne veut pas dire qu'il n'est pas possible de faire √©voluer le fonctionnement du syst√®me pour prendre ces cas en compte si le probl√®me devient suffisamment important, mais il ne faut pas m√©langer les deux cas.

Pour un syst√®me Linux, augmenter le niveau d'isolation pour se prot√©ger pourra ainsi passer par de la virtualisation, ce qui comme dit plus haut fera perdre les b√©n√©fices qu'on peut tirer du partage de ressources.

La prochaine fois que vous prenez connaissance d'une capacit√© d'isolation dans un syst√®me, posez-vous la question{nbsp}: de quel type s'agit-il{nbsp}?

Cela pourrait vous permettre de gagner du temps et d'√©viter des erreurs.