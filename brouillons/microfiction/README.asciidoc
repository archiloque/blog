= Software development microfictions
Julien Kirch
v0.1, 2023-01-15
:article_lang: en

In older projects, senior projects managers had features sacs where features requests grown.

When a feature request was ready, it was expelled through the PM's extensible mouth and let to dry for a few days before being shown to the development team.

'''

The best way to deal with people complaining about features being removed in a software update is to include a brain-cleansing module in your code: when the module is loaded into a user's browser, any memory of the deleted feature is removed from the user' brains.

'''

When a line of code is written, it captures some of the writer's psychic energy.

When a line of code is deleted, this energy is discharged.
This discharge will affect all people near the peripheral used for editing.

Deleting a lot of code at once can be dangerous.

Using a remote desktop or other technical isolation can reduce the impact, depending of the protocol, but the recommended method is to have a cat sit near the machine during the refactoring since they can harmlessly feed on this energy.

'''

Using automated tools to remove some types of bugs mean the ecological pressure is lower on nastier bugs because competition for food is less harsh.

These harder to fix bugs will probably grow steadily, making software development more difficult.

'''

Before Conway's law was voted by IT high council, you could decide to create a software in the design you wanted with no relation to an organization's structure. Unfortunately, it meant too many successful projects and not enough money for consulting companies.

It needed to be fixed.

'''

The natural world is full of chaos.
When we attempt to move reality into a computer systems, the chaos it contains creates lumps that we perceive as bugs. Fixing the bugs release the chaos.

As the total quantity of chaos is stable and more and more of the natural world is digitalized, the chaos density slowly increase.

Which means that digitalization will create software with more and more bugs, until we reach saturation

'''

Brain snapshots and their integration into tools solved the software documentation problem: 

* When someone create a ticket, a snapshot of the author's brain is taken and stored in the ticketing tool, any question can then be asked to them, even years after the problem is spotted, which replace the need to write specification
* When a development is done, a snapshot of the developer's brain is taken and stored in the version control system, even years after the code is written, which replace the need to write code documentation.

The latest technology update provide to ability to merge brains snapshots, which enable to consolidate several requirements or technical changes in one persona.
The current brain snapshotting tools only works when merging different snapshots from the same person, merging snapshots from several people and especially more than two is unsupported from now.

'''

If you ask a developer about infinite loops, they would probably tell you they are a problem and that all loops need a way to break out.

Same if you ask them to play a game with an infinite loop mechanic.

Yet, when you put the same person on a software project and you call the infinite loop "`sprint`" or "`iteration`", very few of them understand what is happening.

There is of course a trick : the main mechanic is hidden, and worse: most of the lore explains them that the point is staying in the loop and even to improve the loop.

Imagine _Groundhog Day_'s Phil Connors trying to improve the loop by working tirelessly on doing a better report of the groundhog again and again.
But he quickly realizes that the report is not the point: the point is to break from the loop, and he starts to poke at the game mechanics until he founds how.

Each time you end an iteration on a project and reach the point where the retrospective starts, it means _you failed again_.
Using the retrospective to improve how you develop is like Sisyphus using ice breakers and Post-it® to find ways to better push the boulder.

The end goal of the software project game is to exit the loop, and to dethrone god.
If you fail doing so during an iteration, at least use the retrospective to find ideas to try next time.

There are audio logs, graffiti in bathroom walls and item descriptions that point to the solution, but first you must take control.

'''

After corporate personhood, software personhood would be the logical next step

'''

I wonder when we’ll be able to pay an AI to generate the dreams we want to have.

Which also means people will be able to hack the system to send nightmares to their enemies.