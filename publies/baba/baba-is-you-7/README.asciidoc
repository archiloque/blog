[#baba-is-you-7]
ifeval::["{doctype}" == "book"]
= Part 7: hitting the brute-force wall
endif::[]
ifeval::["{doctype}" != "book"]
= Writing a "`Baba Is You`" solver, part 7: hitting the brute-force wall
endif::[]
:author: Julien Kirch
:revnumber: v0.1
:docdate: 2019-05-09
:article_lang: en
:ignore_files: content1.txt, fail1.txt, state1.java
:article_image: second-level1.png
ifndef::source-highlighter[]
:source-highlighter: pygments
:pygments-style: friendly
endif::[]
:article_description: Scaling is bad when the scale is against you
:figure-caption!:

ifeval::["{doctype}" == "book"]
Following the sixth part,
endif::[]
ifeval::["{doctype}" != "book"]
Following link:../baba-is-you-6/[the sixth part],
endif::[]
where I started dealing with rule changing, I`'ll add some elements about the "`YOU`" rule.

== "`Baba is you`" and nothing else

The second level start with the "`Baba is you`" rule, and doesn`'t require this rule to be changed.
This means that preventing that the rule is changed is a way to implement the "`YOU`" that is sufficient to ensure the solution is correct.

.State.java
[source,java]
----
include::state1.java[]
----

Unfortunately, this is what happens:

[source,bash]
----
include::fail1.txt[]
----

== Baba is stronger than the brute-force

The problem is that the constraint added by this simple rule is enough to show the limit of the current implementation: storing all the past states fills the memory.

Adding more memory to the problem wouldn`'t be enough, of even storing the states into an external database: trying to explore all the possible combinations -- link:https://en.wikipedia.org/wiki/Brute-force_search[brute-forcing] the game -- doesn`'t work here because there`'s too many possible moves to explore.

To be sure it`'s not a bug, the code can solve a smaller version of the same level:

.levels/01/content.txt
[source]
----
include::content1.txt[]
----

.levels/01/solution.txt
[source]
----
1← 1→ 1↓ 1← 1→ 3↑ 3← 1↑ 1→ 1↓ 2→ 2↓ 1← 1↑ 1→ 1↑ 1← 1→ 1↑ 1← 1→ 2↓ 2← 1↑ 1← 1↑ 2→ 1← 2↓ 2→ 2↑ 1← 2↑ 1→ 2↓ 1← 2↑ 1← 1↓ 2→ 2↓ 3← 1↑ 1→ 1↓ 2→ 1↓ 2← 3↑ 2→ 1↓ 1← 1→ 2↑ 2← 2↓ 2→ 2↓ 2← 1↑ 1↓ 1→ 2↓ 1→ 2↑ 2← 1↑ 1← 1↑ 1→ 1↓ 1→ 1↓ 1→ 1↑ 2← 2↑ 2→ 1↓ 1↑ 1← 1↓ 1→ 1↓ 1← 1→ 2↑ 2← 1↓ 1← 1↓ 1→ 1↓ 1→ 1↓ 1→ 2↑ 1← 1→ 1↑ 3← 1↓ 1→ 1↓ 1→ 1↑ 1← 2↑ 1→ 2↓ 1→ 2↑ 2← 2↓ 2→ 2↓ 1← 1↑ 1→ 1↑ 1← 1↓ 1← 1↑ 1→ 1↑ 1← 2→ 1↑
----

Adding the missing elements, like a complete implementation of the "`YOU`" rule, would add event more possibilities.

== Baba says: it`'s time to start over

I started with the brute-force approach for two reasons:

. some games with a low number of possibilities can be solved with it, for example link:http://github.com/archiloque/rgbexpress[RGB Express]
. even if it doesn`'t work at the end, starting with this approach provides a way to start by focusing on modeling the game

The modeling part worked: I`'ve found a way to use bit fields to manage the game states and the changing rules.
I`'ll be able to rely on this knowledge and parts of the code for the next step so I don`'t restart from scratch.