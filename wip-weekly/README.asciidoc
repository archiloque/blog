= Links - Soon
Julien Kirch
v1.0, 2023-01-01
:article_lang: en
:figure-caption!:
:article_description: 

== link:https://lethain.com/developing-leadership-styles/[Developing leadership styles]

[quote]
____
One of the very first lessons we teach new managers is to be wary of micromanagement. This lesson is so strong for some leaders, that it remains an important leadership principle for them even as they become an executive. When I push such executives to proactively inspect their team’s work, they’ll often earnestly reply that they’ve actively decided not to inspect their team’s work because they don’t want to be a micromanager.
____

[quote]
____
It’s not micromanagement to know what a team is doing. Nor to question the thinking behind a decision they’re making. It’s reasonable to review their goals, and their progress against those goals. It’s OK to talk to their internal and external customers and hear feedback on how it’s going. Those are all activities that empower your team to do meaningful work. If you ever have someone imply that those activities are micromanagement, then it’s far more likely that the individual is misaligned with you than that you are too deep in the details. Don’t let accusations of micromanagement steer you away from doing your job.
____


== link:https://www.infoq.com/articles/architectural-decision-record-purpose/[Has your architectural decision record lost its purpose?]

[quote]
____
* The boundary between architectural and other significant decisions is often ill-defined.  
* All architectural decisions are significant (using the cost of change to measure significance) but not all significant decisions are architectural.
* Just because something is time-consuming to change does not make it architectural.
* Architectural decisions involve the fundamental concepts the system uses because the code implications of the choices are scattered throughout the software rather than being localized. 
* Teams who need to record significant decisions should create a separate Significant Decision Record to avoid overburdening their ADR with other decisions. 
____

[quote]
____
Many teams, lacking a place to record any sort of significant decision, put any decision they consider significant into an ADR, diluting the architectural aspects and turning an ADR into an "`Any Decision Record`". 
____

[quote]
____
To illustrate, a decision to select a database management system is usually regarded as architectural because many systems will use it for their lifetime, but if this decision is easily reversed without having to change code throughout the system, it’s generally not architecturally significant. Modern RDBMS technology is quite stable and relatively interchangeable between vendor products, so replacing a commercial product with an open-source product, and vice versa, is relatively easy so long as the interfaces with the database have been isolated. The _architectural_ decision is the one to localize database dependencies and abstract vendor-specific interfaces, not the choice of the database itself.
____

== link:https://mastodon.social/@mhoye/111295537103529138[Solving problems]

[quote]
____
"`How do I solve this problem?`"

"`You do not. You avoid having that problem in the first place.`"

"`That isn't helpful.`"

"`In fact, it could be.`"

One of the challenges of experience is navigating communications of this general shape. The experience that tells you it's true doesn't necessarily give you a way to communicate how obviously true it is to people who haven't gone through the same.
____

== link:https://www.craigstuntz.com/posts/2023-10-13-learning-compilers-and-programming-languages.html[On learning compilers and creating programming languages]

[quote]
____
When I first started learning about compilers, there was something important which I didn’t understand: Designing a programming language and writing a compiler are two almost entirely different skills. There is obviously some overlap between them, but less than you might think at first!

I think it’s important to know this because they are both very challenging problems! It’s easier to learn these skills if you take them one at a time. Your first solution to a hard problem is likely to be… well, not as good as your tenth! However, it’s pretty common for developers to build out a toy language as they write their first compiler, which means they are making mistakes and learning stuff on two hard problems at once. Worse, those two problems are correlated: A mistake on one will make your life harder on the other. Also, as we will see, although compilers are challenging at first they’re essentially a solved problem, whereas PL design is, let’s say, an area of ongoing research.

I think it’s easier to learn to write a compiler first, and then (if you want) learn to design programming languages. It will be harder to learn to design a good programming language if you don’t have experience with compiler design challenges (amongst other things), so if you want to learn both skills I recommend doing it in that order: Compiler, then PLs. Compiler construction is useful to nearly all software engineers, even (especially?) those who will not build compilers as part of their daytime job. Knowing the challenges of PL design is also useful, but I think in a more abstract way.
____
