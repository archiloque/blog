= Links - Soon
Julien Kirch
v1.0, 2024-01-01
:article_lang: en
:figure-caption!:
:article_description: 

== link:https://yosefk.com/blog/advantages-of-incompetent-management.html[Advantages of incompetent management]

[quote]
____
Well, it's not like they don't care, as much as they don't have a mechanism for caring or even registering it. Correctness is not a goal in itself that management can set for the teams without perverse side-effects. Of course, you have to fix "`showstopper bugs`" or you haven't achieved your goal. Any further bug-fixing takes resources from achieving your nominal goals, and is avoided -- not outright, which would look bad, but through slow-walking and other acceptable forms of sabotage.

It's true that Microsoft Teams (to take one example too many are familiar with) can get away with bugs because it's bundled with Outlook and other stuff, and because whoever pays for it doesn't use it that much, but rather foists it upon helpless internal users. But it's also true that fixing those bugs would be money very well-spent for Microsoft, because it would almost certainly improve their reputation and increase sales at the margins and more than offset the cost of the work. The problem is that it's hard for a well-run place to get people to fix non-showstopper bugs.
____

[quote]
____
Mostly incompetent management which is very bad at setting and achieving goals is perfectly capable and all too likely to cargo-cult effective management by setting up an elaborate bureaucracy for assigning work and tracking its status, thus preventing work from happening spontaneously. This has all the downsides of actually competent management without any of the benefits.
____

== link:https://buttondown.email/nelhage/archive/performance-engineering-requires-stable-benchmarks/[Performance engineering requires stable benchmarks]

[quote]
____
This suggests to me that our very efforts to _improve_ performance at the systems level are actually direct contributors to our struggles to maintain high performance at the application level! All of these innovations improve benchmarks and peak performance figures, and simultaneously making it harder and harder for application developers to do performance engineering, and less and less likely that developers actually do. I definitely don't claim this is at all the full explanation for our slow software, but I think I've convinced myself it's an under-recognized contributor.
____

== link:https://prma.dev/posts/files-as-metadata-format[Files as metadata format]

[quote]
____
File As Metadata Format (FAMF) is not anything horribly new. It is an extension of the Unix way of dealing with information.

[quote]
_____
Everything is a file.
_____

Basically, each field of data is its own file; the key is the file name, and the content of the file is the field content. The exception is when the field is another set of information or a list of this information.
____

== link:https://dl.acm.org/doi/pdf/10.1145/3656404[Refined input, degraded output:
the counterintuitive world of compiler behavior]

[quote]
____
The inconsistent and unpredictable behavior of compilers can be a major obstacle in compiler research and development. Compiler developers are aware of these issues and rely on bug reports or continuous benchmarking to identify them, but the scope of these efforts is limited. Previous work has focused on automatically identifying missed optimizations. None, however, has systematically studied this inconsistent behavior of compilers, i.e., the phenomenon where _more information_ about a programâ€™s semantics causes a compiler to generate _worse_ code. Techniques and tools are necessary for finding such _optimization inconsistencies_, both to help with understanding the unexpected interactions between compiler components, but also to identify these issues and fix the missed optimizations, analysis weaknesses, and unexpected interactions that cause them.
____
