= Links - Soon
Julien Kirch
v1.0, 2022-01-01
:article_lang: en
:figure-caption!:
:article_description: 

== link:https://cohost.org/tef/post/298638-sure-it-didn-t-work[Sure, it didn't work for Email, XMPP, or even Diaspora, but maybe it'll work for us!]

[quote]
____
Federation isn't about giving users freedom, it's about giving nerds a sense of control.

Which is funny, because when you use a federation protocol, that dictates how your software works and functions. You don't get to control how your social network functions, the people writing the software do, and even then they don't always have that much control either. If a big instance changes the way things work, the rest of the network has to fall in line or risk isolation.

A federated model loves to assume that everyone's on a level playing field. That you can just fork the software, run your own service, and do what you like, casually brushing over the reality that the biggest players dictate policy, and that if you don't play along, you won't be part of the network.

This is why so many federated die hards are terrified that Google, Meta, or another giant of industry will join in.

They fear that things will turn out like email, where there's a cartel that controls spam blacklists and smaller email servers routinely get null-routed. They fear things will turn out like XMPP, where a large player captures most of the users, only to turn around and drop compatibility. They fear that a large firm adopts ActivityPub, builds incompatible features atop to lock users in, and shut competitors out.
____

[quote]
____
You can release new features but you might end up breaking old clients.
On the other hand, when you control the server, the client, and the
protocol, it's a lot easier to build out your product and release new
features. Twitter discovered the same thing with third party clients.
Images in tweets? Polls? Video? Bad news if a huge chunk of your
userbase are on an third party client.

In other words: The problem about using a protocol is that you cede
control to it.

Galloway's book
link:https://mitpress.mit.edu/9780262572330/protocol/["`protocol`"] is a dry
and terse academic treatise that covers this in detail, but the lazy
among us can just look at cryptocurrencies, with forks and mining
cartels, to see this in practice. With a protocol, you can't release new
features, you can't change how things work without getting buy-in from
the rest of the network.

When a large player breaks away from a federated network, they're
labeled as a bad actor. Sometimes people point to capitalism as being
the root cause, but i'm more inclined to believe that fragmentation is a
natural consequence of the federated model.
____

== link:https://www.baldurbjarnason.com/2022/theory-building/[Theory-building and why employee churn is lethal to software companies]

[quote]
____
Software is a temporary garden whose fate is inextricably intertwined
with its gardeners. Beyond that, software is a theory. It's a theory
about a particular solution to a problem. Like the proverbial garden, it
is composed of a microscopic ecosystem of artefacts, each of whom has to
be treated like a living thing. The gardener develops a sense of how the
parts connect and affect each other, what makes them thrive, what kills
them off, and how you prompt them to grow. The software project and its
programmers are an indivisible and organic entity that our industry
treats like a toy model made of easily replaceable lego blocks. They
believe a software project and its developers can be broken apart and
reassembled without dying.

What keeps the software alive are the programmers who have an accurate
mental model (_theory_) of how it is built and works. That mental model
can only be learned by having worked on the project while it grew or by
working alongside somebody who did, who can help you absorb the theory.
Replace enough of the programmers, and their mental models become
disconnected from the reality of the code, and the code dies. That dead
code can only be replaced by new code that has been "`grown`" by the
current programmers.

A successful software project is grown from a small living thing to a
larger living thing. Building the project large from the start and will
never come to life. Replacing the gardeners that brought it to life will
lead it to whither.
____

== link:https://pablo.rauzy.name/dev/naur1985programming.pdf[Programming as theory building]

[quote]
____
The present discussion is a contribution to the understanding of what programming is. It suggests that programming properly should be regarded as an activity by which the programmers form or achieve a certain kind of insight, a theory, of the matters at hand. This suggestion is in contrast to what appears to be a more common notion, that programming should be regarded as a production of a program and certain other texts.
____

[quote]
____
Second, the expectation of the possibility of low cost program modifications conceivably finds support in the fact that a program is a text held in a medium allowing for easy editing. For this support to be valid it must clearly be assumed that the dominating cost is one of text manipulation. This would agree with a notion of programming as text production. On the Theory Building View this whole argument is false. This view gives no support to an expectation that program modifications at low cost are generally possible.
____

[quote]
____
On the basis of the Theory Building View the decay of a program text as a result of modifications made by programmers without a proper grasp of the underlying theory becomes understandable. As a matter of fact, if viewed merely as a change of the program text and of the external behaviour of the execution, a given desired modification may usually be realized in many different ways, all correct. At the same time, if viewed in relation to the theory of the program these ways may look very different, some of them perhaps conforming to that theory or extending it in a natural way, while others may be wholly inconsistent with that theory, perhaps having the character of unintegrated patches on the main part of the program. This difference of character of various changes is one that can only make sense to the programmer who possesses the theory of the program. At the same time the character of changes made in a program text is vital to the longer term viability of the program. For a program to retain its quality it is mandatory that each modification is firmly grounded in the theory of it. Indeed, the very notion of qualities such as simplicity and good structure can only be understood in terms of the theory of the program, since they characterize the actual program text in relation to such program texts that might have been written to achieve the same execution behaviour, but which exist only as possibilities in the programmer's understanding.
____
