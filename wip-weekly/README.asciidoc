= Links - Soon
Julien Kirch
v1.0, 2023-01-01
:article_lang: en
:figure-caption!:
:article_description: 

== link:https://www.tedinski.com/2019/02/27/end-to-end-principle.html[The end-to-end principle in distributed systems]

[quote]
____
In the figure above, we have a typical "`accidental database`" scenario. The trouble is that the system (consisting of a server and its backing database, together) has effectively become a database on its own.
____

[quote]
____
Everybody just loves to accidentally start implementing a database, and it's always just queues isn't it?
____

== link:https://www.tedinski.com/2018/10/02/two-sides-to-every-coin.html[The insides and outsides of abstractions]

[quote]
____
There's a long tradition of believing that you can bring non-programmers in to do programming if only X wasn't standing in the way, whatever X is. This has never worked. The one place it has ever had the appearance of working is spreadsheets. But spreadsheets are really just _also programming_, and we just don't really give them the credit they deserve. Spreadsheets are a friendly way to dip your toe into (yes, real) programming. But a lot of these other kinds of tools seem to think it's syntax that's the problem, and it's not. You have to think abstractly and be able to write, test, and debug code. Programming is programming, regardless of syntax.
____


== link:https://www.tedinski.com/2018/03/13/how-compilers-are-designed.html[What can we learn from how compilers are designed?]

[quote]
____
The traditional object-oriented design aesthetic involves a lot of emphasis on encapsulation to achieve loose coupling. The actual designs of data are to be hidden away, so that they can change. Interfaces necessarily hide data members, because you don't know what actual implementation of that interface you might get. Hiding away data representation often gets sold as the key thing that makes OO good at breaking down large problems into smaller pieces.

But here we are, looking at how compilers are designed, and we're achieving loose coupling between components by exposing a data schema, publicly committing to all its representational details. Nothing is encapsulated at all.

"`But what if we need to change that representation?`" one might ask. But this is no real objection. You can make breaking changes to interfaces, too. If it looks like you want to make a breaking change to an interface, you either make the breaking change, or you define a new version of the interface next to it. Likewise with data like this. Data can be an interface.

The fact that data can be an interface should be kind of obvious (file formats? DB schemas? protocols?) but this fact seems to get lost in some OO ideology. It's a natural tool to use between systems, but it often seems to get lost when we're design a single program in an OO language. Instead of passing data from one part of the system to another, we often end up passing references to objects, which ends up creating a dependency between those parts.
____

== link:https://clojure-goes-fast.com/blog/clojures-deadly-sin/[Clojure's deadly sin]

[quote]
____
Regardless of how functionally pure a programming language is, every function will always have at least one side effect -- the time spent to execute it (also, memory allocations, disk I/O, and any other resource usage). By deferring the execution to another point in time, the language makes it harder for the programmer to understand where those CPU cycles are spent
____

== link:https://john.colagioia.net/blog/2023/08/06/code-haunting.html[Software as a Haunting (SaaH?)]

[quote]
____
For example, to me, programming strongly resembles anthropology, in that (among other disciplines) we study how people can best make use of artifacts and how our predecessors worked with and understood problems. We call those ideas "`user experience`" and "`debugging`", but they run at least parallel to anthropological ideas. Or we can talk about programming as storytelling, or any number of other fields.
____

[quote]
____
We often keep objects around past their usefulness, if its imperfections trigger happy memories, and we might want to get rid of a useful thing if those same imperfections trigger unpleasant memories.
____

[quote]
____
We have, in other words, our hauntings. The presences that come along with software make an end-user’s work more difficult or less, concealed under a more unified presentation, in a way that resembles a hypothetical normal-looking house that happens to have presences left over from prior inhabitants.
____

[quote]
____
Likewise, making software "`professional`" often involves a long process of tracking down and exterminating those idiosyncrasies, to replace them with—in effect—the ghost of the corporation that owns and sells the software. In that context, the software needs to "`speak`" with a single voice, not many distinctive voices.
____

== link:https://mjg59.dreamwidth.org/67126.html[Updating Fedora the unsupported way]

[quote]
____
You should not do this. I should not do this. This was a terrible idea. Any situation where you're binary patching your package manager to get it to let you do something is obviously a bad situation. And with hindsight performing 5 independent upgrades might have been faster. But that would have just involved me typing the same thing 5 times, while this way I learned something. And what I learned is "`Terrible ideas sometimes work and so you should definitely act upon them rather than doing the sensible thing`", so like I said, you should not do this in case you learn the same lesson.
____
