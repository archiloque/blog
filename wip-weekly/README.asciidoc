= Links - Soon
Julien Kirch
v1.0, 2022-01-01
:article_lang: en
:figure-caption!:
:article_description: 

== link:https://gankra.github.io/blah/tower-of-weakenings/[The tower of weakenings: memory models for everyone]

[quote]
____
Just to have it upfront, I will start with what The Tower Of Weakenings _is_, and then go back to the motivation and ideas behind it. The Tower Of Weakenings is simply the idea that having One True Memory Model is a frustrating and futile endeavour that leaves no one satisfied. Instead, we should have a _tower_ of Memory Models, with the ones at the top being "`what users should think about and try to write their code against`". As you descend the tower, the memory models become increasingly complex or vague but _critically_ always more permissive than the ones above it. At the bottom of the tower is "`whatever the compiler actually does`" (and arguably "`whatever the hardware actually does`" in the basement, if you care about that).

Here is a sketch of what the tower looks like under my proposal:

. The "`Clean`" Memory Model: a painfully strict and simple model that you can teach and check.
. The "`Real`" Memory Model: similar to the "`Clean`" one, but messier to allow for Useful Crimes.
. The Compiler's Semantics: whatever random primitives compilers expose, and optimizations they do.

In some sense the bottom of the tower is the one that "`matters`" because that's the thing that (mis)compiles your code, but it's also a shifting target, and link:https://gankra.github.io/blah/initialize-me-maybe/[trying to expose its semantics leads to sadness]. Unfortunately, this is also basically true of "`real`" memory models. link:http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2676.pdf[We're still trying to figure out what on earth C's memory model is], and every language infamously defers to "`the C11 memory model`" on hard questions. So as an educator, I eventually have to bottom out on sending you a shrug-emoji if you keep asking for what the real rules are. No one really knows!
____

[quote]
____
Ok yes get your jokes out about solving all problems with another layer of abstraction, but this is _painfully_ needed. And really, what I'm doing here isn't _adding_ a layer but cleaving a bloated and messy layer into two much more manageable parts. No offense to all the people doing great work on memory models, but as far as I'm concerned they've been given an impossible task. There are simply too many competing concerns and stakeholders to produce a _truly_ satisfying design for all of them. Here are some of the many stakeholders:

* Millions of lines of ancient code that are doing whatever because we can't explain the rules
* Random programmers who barely read the docs and are just doing The Idiomatic Thing
* Hardcore performance junkies who insist the fucked up thing they made should be legal
* Hardcore safety junkies who insist they should be able to validate the correctness of their code
* Compiler developers who want to know what optimizations they can or can't do
* Library developers who want to know what interfaces/idioms to design around
* Tooling developers who want to build sanitizers that reliably detect UB when it happens
* Teachers who want to help everyone else understand the PhD thesis on their desk.
* Memory model people who just want this all to be coherent and formalized and validated

And all of these people are working _together_ so they all agree that whatever the other person claims they need to do their job should definitely be allowed, because they want to all mutually benefit. And definitely make sure not to break all that code or even make it run slower! kthxbai!
____

[quote]
____
Critically, the fact this lie is part of The Tower Of Weakenings means that if you follow its rules, then whatever the "`real`" model is _doesn't matter anymore_. We will absolutely guarantee that your code works, because you followed the really strict and simple rules that _everyone_ can agree _obviously_ have to work. Just as you're not supposed to worry about the compiler backend you're using, you shouldn't have to worry about the fiddly details of what the current working memory model is.
____


== link:https://nilsnh.no/2022/04/09/innovating-beyond-libraries-and-frameworks/[Innovating beyond libraries and frameworks]

[quote]
____
I have been a big fan of the link:https://www.brandons.me/blog/libraries-not-frameworks[write libraries, not frameworks] argument for a while now. Lately, I’ve come to ponder that there might be a fruitful expansion to this argument, that we should start to value principles over patterns, patterns over libraries, and libraries over frameworks.

Let’s clarify some terminology:

* _Framework_: This is (usually) someone else’s code that calls your code. In order for this to work your code will need to conform to constraints set down by the framework. These constraints are often firm boundaries that’s hard to code around. On the flipside by coding within the framework’s conventions and constraints you tend to get a lot of useful functionality out of the box making coding quicker.
* _Library_: This is (usually) someone else’s code that _you call_ from your code. A library tends to be some code that imposes fewer constraints on your code as compared to frameworks. By using one or more libraries you’re able to reuse someone else’s code to solve your problems. Libraries are easier to combine and interchange, while putting frameworks on top of frameworks can lead to a bad time.
* _Pattern_: This is a descriptive, reusable _approach_ to writing your code (see: link:https://en.wikipedia.org/wiki/Software_design_pattern[software design pattern]). Patterns range in their vaguenes, applicability and prescriptiveness. Examples of programming patterns include link:https://www.itamarweiss.com/personal/2018/02/28/return-early-pattern.html[early-return pattern], link:https://en.wikipedia.org/wiki/Builder_pattern[builder-pattern], link:https://en.wikipedia.org/wiki/Actor_model[actor model], link:https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller[model-view-controller], link:https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/[onion architecture], link:https://en.wikipedia.org/wiki/Microservices[microservices], link:https://m.signalvnoise.com/the-majestic-monolith/[majestic monolith], link:https://en.wikipedia.org/wiki/Monorepo[monorepos], and link:https://en.wikipedia.org/wiki/React_(JavaScript_library)#Unidirectional_data_flow[flux architecture]. These are just some patterns that I can think off from the top of my head, but there are many books that cover programming patterns.
* _Principle_: This is some general guidance or philosophy expressed as rules (like a rule of thumb) that helps you write good code. Although programming is a very young field — for instance compare this to the field of carpentry who have been building houses for thousands of years — developers have managed to distill some useful principles to aid themselves in their work. Examples of principles include link:https://simple.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID principles], link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[Don’t repeat yourself (DRY)], link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[You Aren’t Gonna Need It (YAGNI)], link:https://agilemanifesto.org/[Agile manifesto], link:https://en.wikipedia.org/wiki/Law_of_Demeter[Law of Demeter], link:https://www.hyrumslaw.com/[Hyrum’s law]. There are many more to be found out there, and as I write this I just discovered link:http://principles-wiki.net[this site that collects programming principles], nice!
____
