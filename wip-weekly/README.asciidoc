= Links - Soon
Julien Kirch
v1.0, 2022-01-01
:article_lang: en
:figure-caption!:
:article_description:

== link:http://neugierig.org/software/blog/2016/04/typescript-types.html[Rethinking errors, warnings, and lints]

[quote]
____
Invariants, and inform versus block
How we maintain invariants is more interesting. What do you do when a check finds a problem? There are two basic options: either inform the programmer and move on, or block forward progress.

Here's a warm up to make this more concrete. In most statically typed languages, a type error stops compilation, so you could say that for a type problem the compiler must block at build time. But even something as apparently fundamental as this is not fixed! For one counterexample, TypeScript can be configured to generate code regardless in the presence of type errors (which link:http://neugierig.org/software/blog/2016/04/typescript-types.html[never affect runtime behavior anyway]).

You could imagine even a C compiler could choose "`inform`" on a type problem and generate a runtime failure in its place, to allow you to run the resulting program. (I've heard some tools in the Java ecosystem can already do this, perhaps?) This behavior is plausibly useful when developing, where you want to iterate on module A of a program while you ignore type problems in irrelevant module B that you know you won't execute while you are working on A.

In principle then at least, for any problem you could choose between blocking and informing, and informing lets the programmer choose whether to stop rather than forcing it. At any given moment there are surely hundreds of different ways the code could be improved, some of them not even detectable by your tools; in my experience there's never a shortage of known flaws in a given codebase, and the hard problem is instead how to prioritize these problems. When we block on one problem what we're effectively saying is that of all the different things that could be worked on, the problem you just identified is absolutely the highest priority to fix, so much so that you cannot be allowed to work anything else before fixing it.
____

[quote]
____
But importantly, it's also useful to be able to relax an invariant. While developing, you might wanna sprinkle in some printfs while debugging something and you don't want to worry about appeasing the XSS checker as you do it. It's valuable both to be able to sprinkle those prints (not blocking on error at the run phase) while also guaranteeing that you never deploy such code (blocking at the commit or deploy phase).

The pattern of informing in one phase followed by blocking in a later one is a nice way to softly introduce an invariant while still giving the programmer some wiggle room while developing. For example, most problems that block at a later phase (such as a blocking build problem) can usefully be informed during the editing phase (as a highlight in the editor) as a way of shortening the development loop. Another example of this pattern in practice is in projects that provide a warning-only linter during development, but then require code to be lint-clean before submitting it.
____

[quote]
____
One objection you might have at this point is something about how compilers typically check "`important`" problems and linters check "`unimportant`" problems. This is true to an extent but it's also often kind of a historical accident; there's plenty of unimportant things a compiler can complain about, and there are plenty of lint-like tools that link:https://errorprone.info/bugpatterns[discover real problems]. And this also explains why different compilers might treat different problems as either a warning (inform) or error (block) kind of problem.
____

[quote]
____
For this reason, in the past I have believed the right approach is to just let programmers ignore (bypass) low-confidence checks; for example, you could decide that some lint check is purely a guess and that you should feel free to commit code even when it fires. I have since come around to seeing this is a bad idea, because it means that the next person who edits the code will need to reevaluate the same question, and a system where you regularly need to disregard warnings leads to warning blindness. Instead, I think a better mechanism for responding to checks is for programmers to annotate code directly.
____
